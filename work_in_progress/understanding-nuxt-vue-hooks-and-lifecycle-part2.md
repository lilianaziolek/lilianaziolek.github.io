---
title:  "Understanding Nuxt & Vue hooks and lifecycle (part 2)"
categories:
  - front-end
tags: 
  - vuejs
  - nuxt
  - javascript

---

This is part 2 of mini-series - Understanding Nuxt & Vue hooks and lifecycle. You can start with [Part 1 here](https://tech.onestopbeauty.online/front-end/understanding-nuxt-vue-hooks-and-lifecycle-part1/), to make sure you are at least vaguely familiar with most of the required concepts. If you have other programming background, but not in Vue/Nuxt, you might also find useful [my other post](https://tech.onestopbeauty.online/high-level/quick-guide-to-javascript-ecosystem-from-senior-java-dev-pov/).  

# What's in the app 
The [sample code](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples) contains very simple examples of all the mechanisms/hooks discussed in Part 1, mostly in the form of logging what's happening. Noteworthy files:
* [LinksComponent.vue](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/components/LinksComponent.vue)
  * Contains a (hardcoded) list of various links in the project to allow user-navigation. 
  * Includes **mixin** [logRouteQueryAndParams.js](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/mixins/logRouteQueryAndParams.js) to demonstrate that what's in mixin (computed property *routeParams*) is executed in a same way as if it was directly defined in the component, and that mixin code has access to *this*.
  * Shows most of the Vue component lifecycle methods  
* [globalMiddleware.js](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/middleware/globalMiddleware.js) and [localMiddleware.js](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/middleware/localMiddleware.js) - as the names suggest, global middleware is attached from `nuxt.config.js` and thus executed before every route, whereas local middleware is only included for `test1/_param1/_param2` route. 
* A few routes (pages):
  * [index.vue](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/pages/index.vue) - the starting point, contains LinksComponent
  * `test1/param1?/param2?` - a route with two optional parameters, meaning that `test1/`, `test1/lorem` and `test1/lorem/ipsum` all would land on the page generated by code in [_param2.vue](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/pages/test1/_param1/_param2.vue) file
  * `test1/param1?/param2?` - a route completely equivalent to test1 route, it's just to show that if you don't like naming your vue files with the name of last parameter to the route, you can name place them in subdirectory and name them [index.vue](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/pages/test2/_param1/_param2/index.vue) instead
  * `foo/x/_id?` and `foo/y/_id?` - this is to show how dynamic nested routes work. A nested route is where a page contains another router-view component, like in [foo.vue](https://github.com/lilianaziolek/blog-examples/blob/master/dry-examples/pages/foo.vue). You always get one by default with Nuxt (you don't explicitly include it, Nuxt does it for you), so this is effectively a router-inside-router. Hence the name, **nested**.

# How it all works? 
Let's assume the user first navigates to our main page (e.g. http://localhost:3000) followed by navigating to various other pages, by clicking appropriate links. You need to click on the links rather than put URLs directly in the browser if you want to observe SPA mode in action. This is because by navigating from address bar you would force SSR mode.

The table below shows the results of the user journey:

<table>
<tr>
<th>User location</th>
<th>Log output</th>
<th>What's happening?</th>
</tr>

<tr><td style="width:10%">(first visit) http://localhost:3000</td><td style="width:50%">

*On the server, before answer returned to client:*
```
(AlternativeEventBus Plugin) SSR: true inject component with id: 4
(NuxtServerInit) SSR: true
(Global Middleware) SSR: true
(LinksComponent) SSR: true [BeforeCreate]
(LinksComponent) SSR: true [Created] SampleProp: Prop from main page, SampleData: Lorem Ipsum Data
(LinksComponent) Created Refs:
```
*On the client (browser) side:*
```
(EventBus Plugin) SSR: false inject component with id: 1
(AlternativeEventBus Plugin) SSR: false inject component with id: 2
(LinksComponent) SSR: false [BeforeCreate]
(LinksComponent) SSR: false [Created] SampleProp: Prop from main page, SampleData: Lorem Ipsum Data
(LinksComponent) Created Refs:
(LinksComponent) SSR: false [Mounted] SampleProp: Prop from main page, SampleData: Lorem Ipsum Data
(LinksComponent) Mounted Refs: Foo With No Params,Foo X With Param1,(...)
```
</td><td style="width:40%">

* globalMiddleware is only executed in SSR in this call
* *AlternativeEventBus Plugin* id is different on client and server (if this is not the case for you, refresh the page, as ID on the server will change on subsequent SSR calls). That's because this plugin's code is executed on both client and server, and both sides create an object.
* *EventBus Plugin* is only setup on the client. I'll write more about eventBus concept in a separate post 
* beforeCreate and created are called on both server and client
* Mounted is only called on the client
* this.$refs are only populated in Mounted
</td></tr>

<tr><td>Click on link <b>Test1 with Param 1</b> => http://localhost:3000/test1/val1</td><td>

*In this, and all the following calls everything happens on the client (browser) side only :*
```
(Global Middleware) SSR: false
(Local Middleware) SSR: false
(Mixin) /test1/val1AsyncData: {"param1":"val1"}
(Mixin) /test1/val1Fetch: {"param1":"val1"}
(LinksComponent) SSR: false [BeforeCreate]
(LinksComponent) SSR: false [Created] SampleProp: Test1, SampleData: Lorem Ipsum Data
(LinksComponent) Created Refs: 
(LinksComponent) SSR: false [Mounted] SampleProp: Test1, SampleData: Lorem Ipsum Data
(LinksComponent) Mounted Refs: Foo With No Params,Foo X With Param1,(...)
```
</td><td>

* Global Middleware, and now also local middleware, are processed on the client.
* Mixin code from *logRouteQueryAndParams* for fetch and asyncData is now called. Note, it was not called on home page - that's because index.vue does not include it as mixin, and _param2.vue does. LinksComponent does contain this mixin too, but **asyncData and fetch are not called for components**
* all Vue lifecycle hooks from LinksComponent are called again, because the route has changed and the instance of LinksComponent that was used in index.vue would now be destroyed and a new one created 
</td></tr>

<tr><td>Click on link <b>Test2 with Param1/Param2</b> => http://localhost:3000/test2/val1/val2</td><td>

```
(Global Middleware) SSR: false
(Mixin) /test2/val1/val2AsyncData: {"param1":"val1","param2":"val2"}
(Mixin) /test2/val1/val2Fetch: {"param1":"val1","param2":"val2"}
(LinksComponent) SSR: false [BeforeCreate]
(LinksComponent) SSR: false [Created] SampleProp: Test32, SampleData: Lorem Ipsum Data
(LinksComponent) Created Refs: 
(LinksComponent) SSR: false [Mounted] SampleProp: Test2, SampleData: Lorem Ipsum Data
(LinksComponent) Mounted Refs: Foo With No Params,Foo X With Param1,(...)
```
</td><td>

* Global Middleware is processed on the client. Local is not as it was not attached to this route.
* Mixin code from *logRouteQueryAndParams* for fetch and asyncData is now called.
* all Vue lifecycle hooks from LinksComponent are called
</td></tr>

<tr><td>Click on link <b>Foo X with Param1</b> => http://localhost:3000/foo/x/val1</td><td>

```
(Global Middleware) SSR: false
(Mixin) /foo/x/val1AsyncData: {"id":"val1"}
(Mixin) /foo/x/val1Fetch: {"id":"val1"}
(Mixin) /foo/x/val1AsyncData: {"id":"val1"}
(Mixin) /foo/x/val1Fetch: {"id":"val1"}
(LinksComponent) SSR: false [BeforeCreate]
(LinksComponent) SSR: false [Created] SampleProp: SampleProp from Foo, SampleData: Lorem Ipsum Data
(LinksComponent) Created Refs: 
(LinksComponent) SSR: false [Mounted] SampleProp: SampleProp from Foo, SampleData: Lorem Ipsum Data
(LinksComponent) Mounted Refs: Foo With No Params,Foo X With Param1,(...)
```
</td><td>

* Global Middleware is processed on the client.
* Mixin code from *logRouteQueryAndParams* for fetch and asyncData is now called - TWICE! This is because both foo.vue, and foo/x/_id.vue include the mixin, and both are pages. In reality, you wouldn't normally have the same fetch included in parent and nested route, so the fetch/asyncData would not be doing the same thing.
* all Vue lifecycle hooks from LinksComponent are called
</td></tr>

<tr><td>Click on link <b>Foo Y with Param2</b> => http://localhost:3000/foo/x/val1</td><td>

```
(Global Middleware) SSR: false
(Mixin) /foo/y/val1AsyncData: {"id":"val1"}
(Mixin) /foo/y/val1Fetch: {"id":"val1"}
```
</td><td>

* Oh dear! What just happened?! Why is this output so different than for Foo X? This is because we are navigating within a nested route now. The app is smart enough to know that the shell (foo.vue) has not changed between foo/x/val1 and foo/y/val1 - it's only the nested part (x/_id.vue vs y/_id.vue) that has changed. Therefore, there is no point regenerating anything related to foo.vue. We only execute what's specific to y/_id.vue - and this file does not contain a separate LinksComponent, so does not generate its lifecycle methods. 
* Global Middleware is still processed on the client.
* Mixin code from *logRouteQueryAndParams* for fetch and asyncData is now called - but only for foo/y/_id.vue
</td></tr>

</table>

 
